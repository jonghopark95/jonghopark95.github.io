---
layout: post
title: 로그인 인증 프로세스
summary: 로그인 프로세스에 대해 서술해보았습니다.
featured-img: reactjs
---

## 개요

### 서버 기반 인증
HTTP는 response를 받으면 connectionless가 되고 통신이 종료되면 어떠한 상태 정보도 남지 않는다. (stateless)

따라서 로그인 후 다시 웹페이지에 접근하면 로그인 상태가 유지되지 않으므로, 이를 위해 세션과 쿠키를 사용한다.

과정은 다음과 같다.
1. 사용자가 로그인 한다. (로그인 정보 서버로 request)
2. request가 들어오면 사용자 검증 후 사용자 고유한 ID를 부여하여 세션 저장소에 저장한 후 이에 연결되는 세션 ID를 생성하여 response header에 포함시켜 반환한다.
3. 사용자는 서버에서 세션 ID를 받아 쿠키에 저장한 후, 인증이 필요한 end point에 접근할 때마다 쿠키를 request header에 포함시켜 보낸다.
4. 서버는 쿠키를 받아 세션 저장소에서 검증한 후 요청에 해당하는 데이터를 반환한다.

- 특징
  - 쿠키는 HTTP 요청 중 노출되어도 세션 ID이기 때문에 중요한 정보는 담겨있지 않다. 그러나 쿠키 자체를 훔쳐 세션에 접근하여 중요한 정보를 빼낼 수 있다. 이를 위해 세션에 유효시간을 넣거나 HTTPS를 사용해 그 안의 정보를 보기 힘들게 할 수 있다.
  - 쿠키를 통해 세션에 접근하면 세션 ID로 사용자를 구분할 수 있으므로 일일히 사용자 정보를 확인할 필요가 없다.
  - 서버에 세션을 저장하기 때문에 사용자 수가 많아지면 서버의 부담이 늘어난다. 또, 서버 확장성(scalability)이 나빠진다. 
  - 쿠키는 단일 도메인, 서브 도메인에서만 작동하도록 설계되어 여러 도메인에서 관리하기 번거롭다.

### 토큰 기반 인증
세션 기반 인증과 달리 서버가 사인한 토큰을 이용해 인증을 수행하는 방식이다.

세션 기반의 stateful 서버는 클라이언트의 상태를 유지한다. 사용자가 인증을 요청하면 stateful 서버는 성공했을 때의 결과 (세션)을 유지하기 때문에 서버에 부하가 발생할 수 있다.

하지만 토큰 기반 인증은 stateless 서버를 사용하며 상태 정보를 유지하지 않는다.

서버가 전달받은 토큰을 검증만 하면 되기 때문에 서버의 부담을 줄이고 서비스의 확장성을 높일 수 있다.

과정은 다음과 같다.
1. 사용자가 로그인한다.
2. 서버는 request가 들어온 사용자 정보를 검증하고 유효한 경우 정상적으로 발급된 토큰임을 증명하는 signature를 갖는 토큰을 클라이언트에 반환한다.
3. 클라이언트는 토큰을 저장하고 서버 요청 시 해당 토큰을 request header에 담아 서버에 전달한다.
4. 서버는 토큰을 검증한 후 요청에 응답한다.

- 특징
  - stateless server
    - 클라와 서버의 연결고리가 없으므로 scalability가 높아진다.
  - 플랫폼 간 권한 공유
    - 소셜 계정등을 이용해 다른 웹서비스에서 로그인 할 수 있다.
  - csrf 방지
    - 사용자가 사이트를 벗어나도 저장된 정보에 사용자 정보가 있으므로 공격자에게 노출될 수 있다. 공격자가 다른 URL로 유도하여 비밀번호 변경이나 탈퇴를 요청할 경우 서버는 요청을 신뢰하고 작업을 수행하게 된다. 이러한 문제를 해결하기 위해 탈퇴 시 비밀번호를 한번 더 요구하거나 토큰과 같은 credential을 포함시킬 수 있다.
  - cors
    - 쿠키는 여러 도메인에서 관리하기 힘들지만 토큰은 유효하다면 어디에서든 작동할 수 있다.
- 문제점
  - stateless 하므로 강제 만료 할 수 없다. 토큰이 공격자에게 탈취되면 토큰이 만료될 때까지 공격자가 요청할 수 있다. 이러한 문제로 토큰의 만료 주기를 짧게 할 경우 수시로 로그인을 다시 해야하며 길게 하면 피해가 커진다. 이를 위해 보통은 refresh 토큰과 access 토큰을 나누어 사용한다. 액세스 토큰은 서버를 요청할 때 사용되며 만료 주기가 짧고, 리프레시 토큰은 액세스 토큰을 제발급 할 수 있으며 보안이 철저하며 만료 주기가 길다. 
- 토큰 저장 위치
  - 토큰이 전달되는 방식은 크게 두 가지로 나뉜다.
  - 웹 스토리지 (localStorage, sessionStorage)
    - 로그인 성공 시 토큰을 웹 스토리지에 넣고 웹 요청을 할 때마다 HTTP 헤더 값에 넣어서 요청을 하는 방법이다. 구현하기 쉽고 하나의 도메인에 제한되지 않지만 XSS 해킹으로 매우 쉽게 토큰이 탈취될 수 있다.
  - 쿠키
    - 쿠키를 정보 전송 수단으로 사용한다. 서버 측에서 응답을 하며 쿠키를 설정할 때 httpOnly 값을 활성화해주면 네트워크 통신 상에서만 해당 쿠키가 붙게 되므로 JS로 토큰 값에 접근하는 것이 불가능해진다.
    - 그러나 쿠키는 한정된 도메인에서만 사용 가능하다. 이는 토큰이 필요해 질 때 현재 쿠키에 있는 토큰을 사용하여 새 토큰을 문자열로 받아올 수 있게 하는 API를 구현하면 된다.
    - 또 다른 단점은 XSS에서 해방되는 대신 CSRF 공격에 위험성이 생긴다는 점이다. 이는 HTTP request referer 체크, CSRF 토큰 사용을 통해 방지할 수 있다.

### JSON Web Token (JWT)
JWT는 인증 헤더 내에서 사용되는 토큰 포멧이다. 토큰은 Base64로 인코딩한 String으로 이루어져 있다. JWT는 두 개의 시스템 끼리 안전한 방법으로 통신할 수 있도록 설계하는 것을 도와준다.

JWT의 장점은 계정 서버와 API 서버가 분리되어 있을 때, API 서버가 토큰의 유효성 여부를 계정 서버에게 물어보지 않고도 스스로 판단할 수 있다는 것이다.

Access Token은 단순히 자원에 접근하는 것 뿐만 아니라 권한 / 인증에 대한 token을 말한다.
Refresh Token은 Access token의 탈취 문제를 해결하기 위해 발급하는 토큰이다.
긴 유효기간을 가지며 Access token이 만료되었을 때 새로 발급해주는 열쇠가 된다.

JWT는 토큰 자체가 의미를 갖는 claim 기반의 토큰으로 권한과 인증의 역할으 가질 수 있다.
claim은 사용자에 대한 프로퍼티나 속성으로, 즉 JWT는 json 객체에 요구사항을 작성하고 암호화 방식을 사용해 문자열로 인코딩 한 후 HTTP header에 추가함으로써 사용자 인증을 요청한다.

서버는 이 토큰을 확인한 후 디코딩하여 사용자를 인증하게 된다.

- 특징
  - Stateless
  - 확장성
    - 토큰 기반으로 하는 다른 인증 시스템에 접근 가능
  - 무결성 : HMAC(Hash-based Message Authentication)
    - JWT Token은 변조가 되었을 때 바로 알아차릴 수 있다.
  - 보안
    - 권한을 부여하기 위한 데이터가 JWT안에 모두 담겨 있다. OAuth처럼 인증 서버에서 토큰에 대한 정보를 찾을 필요가 없다. 

JWT의 구조
1. Header : 토큰 타입과 암호화 방법을 보관한다. 
2. Payload : 유저 정보, 상품 정보 등 다양한 종류의 정보를 넣을 수 있다.
3. Signature : Header, Payload, Secret Key의 조합이다.

처리 과정은 다음과 같다. * 처음 사용자를 등록할 때 Access token과 Refresh token이 모두 발급되어야 한다.
1. 사용자가 로그인한다.
2. 서버는 요청을 확인하고 사용자를 검증한 후, 고유 ID값을 부여해 기타 정보와 함께 Payload를 작성하여 암호화할 secret key와 함께 access token을 발급하여 클라이언트로 반환한다.
3. 이후 사용자가 jwt가 요구되는 API를 요청할 때 클라이언트가 Authorization header에 Access token을 담아서 보낸다.
4. 서버는 Access token(JWT)의 Signature를 secret key를 통해 복호화하여 검증한 후 Payload를 디코딩하여 사용자 정보를 확인해 요청한 데이터를 클라이언트로 반환한다.

Access token + Refresh Token Process
1. 사용자가 로그인한다.
2. 서버는 요청을 확인하고 사용자를 검증한 후, Access token, Refresh token을 발급한다.
3. 사용자는 Refresh token은 안전한 저장소에 저장 후 access token을 헤더에 실어 요청을 보낸다.
4. Access token을 검증하여 이에 맞는 데이터를 보낸다.

...

5. 시간이 지나 Access token이 만료된 후 사용자가 요청을 보내면 만료됨을 확인하고 권한 없음을 보낸다.
6. 사용자는 Refresh token, access token을 함께 보낸다.
7. 서버는 access token의 무결성을 확인한 후 사용자 db에 저장되어 있던 refresh token을 비교한다. 동일하고 유효기간도 지나지 않았다면 새로운 access token을 발급해준다.
8. 사용자는 새로운 access token을 헤더에 실어 다시 요청을 진행한다.

Access token이 만료될 때마다 권한 없음을 확인할 필요 없이 사용자가 payload의 유효기간을 확인하여 바로 재발급 요청을 할 수도 있다.

### Access token, refresh token의 저장

API 요청을 할 때 Access token을 사용하고, 만료된 후 새로운 토큰을 얻기 위해 refresh token을 사용한다.
Access token은 주로 세션, refresh token은 주로 DB에 저장한다.

## OAuth
OAuth는 외부 서비스 인증 및 권한 부여를 관리하는 범용적인 프로토콜이다.
- 권한 : OAuth는 인증 뿐만아닌 권한도 관리한다. 사용자의 권한에 따라 접근할 수 있는 데이터가 다르도록 설정 가능하다.
- 프로토콜 : Facebook, Google, naver는 Oauth라는 규격에 맞춰 인증 및 권한을 대행관리해준다.
- 외부서비스 ; 외부 서비스를 위한 서비스인 OAuth는 우리 서비스의 인증 및 권한 부여 관리를 대행해준다.

## OAuth 2.0
OAuth는 2007년에 1.0이 발표되었으나 커져가는 네트워크 시장에서 한계가 보이며 2.0으로 바뀌게 되었다. 크게 바뀐 점은 다음과 같다.
1. 모바일 어플리케이션에도 사용 가능
2. 반드시 HTTPS를 사용하기 때문에 보안 강화
3. Access Token 만료기간 생김

인증 방식은 크게 4가지이다.
1. Authorization Code Grant
2. Implicit Grant
3. Resource Owner Password Credentials Grant
4. Client Credentials Grant

## 그래서 로그인 조건은??
1. JWT를 이용한 인증 방식 사용
2. refreshToken을 secure httpOnly 쿠키에 저장해 CSRF 공격 방어
3. accessToken을 웹 애플리케이션 내 로컬 변수에 저장해 사용, API를 요청할 때 Authorization 헤더에 넣어 보내줌
4. XSS 취약점을 이용한 API 요청 공격 방어할 것



## 참고

- [서버 / 토큰 기반 인증](https://dooopark.tistory.com/6)
- [OAuth](https://tansfil.tistory.com/60?category=255594)
- [react 안전하게 로그인 처리하기](https://velog.io/@yaytomato/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%90%EC%84%9C-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0)